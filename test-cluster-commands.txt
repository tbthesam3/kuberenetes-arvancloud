âœ… CoreDNS Ø¯Ø±Ø³Øª Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ù‡
âœ… DNS Resolution Ø³Ø§Ù„Ù…Ù‡
âœ… Calico Ø´Ø¨Ú©Ù‡ Ø±Ùˆ Ø¯Ø±Ø³Øª Route Ú©Ø±Ø¯Ù‡
âœ… Pod â†’ Internet OK
ðŸŽ‰ Ú©Ù„Ø§Ø³ØªØ± Ú©Ø§Ù…Ù„Ø§Ù‹ Ø³Ø§Ù„Ù…Ù‡

kubectl run test-pod-1 -it --rm --image busybox -- ping google.com


ðŸ§ª ØªØ³Øª 1: Ø¢ÛŒØ§ DNS Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ù‡ØŸ
kubectl run -it --rm dns-test \
--image=busybox --restart=Never -- nslookup google.com

ðŸ§ª ØªØ³Øª 2: Ø¨Ø¯ÙˆÙ† DNSØŒ Ù…Ø³ØªÙ‚ÛŒÙ… IP
kubectl run -it --rm net-test \
--image=busybox --restart=Never -- ping 8.8.8.8


ðŸ§ª ØªØ³Øª 3: DNS Ø¯Ø§Ø®Ù„ÛŒ Kubernetes
kubectl run -it --rm dns-int \
--image=busybox --restart=Never -- nslookup kubernetes.default


sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1   Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ø¨Ø±Ú¯Ø±Ø¯ÙˆÙ†Ù‡


kubeadm init phase addon kube-proxy \
  --config /opt/kubeadm_config.yml
  
kubectl run test-pod-2 -it  --image busybox -- cat /etc/resolv.conf
 default.svc.cluster.local svc.cluster.local cluster.local   ====> in bayad bashe  
 
Test-Nginx:

We will now also verify that kubernetes built-in DNS works across namespaces. Create a namespace:
```
kubectl create namespace dev
```
Create an nginx deployment and expose it within the cluster:
```
kubectl create deployment nginx --image=nginx -n dev
kubectl expose deployment nginx --port 80 --type ClusterIP -n dev
```
Run a temporary container to see if we can reach the service from the default namespace:
```
kubectl run curly -it --rm --image curlimages/curl:7.70.0 -- /bin/sh
curl --head http://nginx.dev:80
```
 
 